### 一、一致性
高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但也存在缓存一致性（cache coherence）问题
### 二、java内存模型
内存模型：对特定的内存或高速缓存进行读写访问的过程抽象。
java内存模型（java memory model,JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下
都能达到一致的 内存访问效果。

#### 1、主内存与工作内存
Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
此处变量包括：实例字段、静态字段、构成数组对象的元素；不包括：局部变量、方法参数，因为他们是线程私有，存放在栈中。

Java内存模型规定了所有的变量都存放在主内存中。每个线程还有自己的工作内存，线程的工作内存保存了被该线程使用到变量的
主内存副本拷贝，线程对变量的所有操作（读、写）都必须在工作内存中进行，而不能直接读写主内存中的变量。
不同的线程之间无法直接访问对方的工作内存中的变量，线程间变量值传递需要通过主内存来完成。

主内存主要对应Java堆中对象实例数据部分，工作内存对应虚拟机栈中部分区域。

#### 2、内存间交互操作
主内存与工作内存交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存，java内存模型中定义了以下8种操作
来完成，虚拟机保证每一种操作都是原子的、不可在分的，
* lock(锁定)：作用于主内存的变量，它把一个变量标识为一个线程独占状态；
* unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后变量才可以被其他线程锁定。
* read(读取)：作用于主内存变量，把一个变量值从主内存传输到线程工作的内存中，以便随后的load动作使用。
* load(载入)：作用于工作内存变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。
* use(使用)：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值得字节码指令时执行。
* assign(赋值)：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行。
* store(存储)：作用于工作内存的变量，把工作内存中一个变量的值传递到主内存中，以便随后的write操作使用。
* write(写入)：作用于主内存的变量，把store操作从工作内存中得到的变量值放入主内存变量中。

如果要把一个变量从主内存中复制到工作内存，就要顺序执行read、load操作。
如果把一个变量同步回主内存，就要顺序执行store、write操作。

执行上述8中操作时必须满足如下规则：
* 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发钱会写，但主内存不接受。
* 不允许一个线程对其他的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
* 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。
* 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load,assign）的变量,换句话说，就是对一个变量实施
use、store操作前，必须先执行assign和laod操作
* 一个变量在同一个时刻只允许一个线程对其进行lock操作，但lock操作可以被同一个线程执行多次，多次lock需对应多次unlock
* 如果对一个变量执行lock，那将会情况工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign
* 如果一个变量事先没有被lock，那就不允许执行unlock操作，也不允许unlock一个被其他线程锁住的变量
* 对一个变量执行unlock之前，必须先把次变量同步回主内存中


#### 3、对于Volatile型变量的特殊规则

volatile类型变量具备两种特性：
* 保证此变量对所以线程可见性,也就是当一个线程修改了这个变量的值，新值对于其他线程来说是立即可知的。
但要确保线程安全，就必须符合单一线程修改volatile变量的值，或者运算结果不依赖变量的当前值。

* 禁止指令重排序优化，如果没有将变量设置为volatile型，指令重排序优化可能将部分代码提前执行而产生错误。

如何实现可见性，使用前都必须从主内存中刷新最新的值。

#### 4、对于long和double类型变量的特殊规则

允许虚拟机将非Volatile类型的64位数据类型(long、double)的读写操作分为两次32位操作来进行，这就是long、double的分原子性协定。
但允许虚拟机选择把这些操作实现为具有原子性的操作，目前商用虚拟机都选择把64位的数据读写操作为原子操作来对待。

#### 5、原子性、可见性、有序性
java内存模型是围绕着在并发过程中如何处理原子性、可见性、有序性这3个特征来建立的。

**原子性** ：由java内存模型来保证原子性变量操作包括read、load、assign、use、store、write，大致可以认定基本数据类型
的访问读写是具备原子性的。

**可见性**：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。java内存模型是通过在变量修改后将新值同步回主内存，
在变量读取前冲主内存刷新变量值这种依赖主内存作为传递媒介方式实现的。无论普通变量还是volatile都是如此，volatile特殊规则保证了
新值能够立即同步到主内存，以及每次使用前立即从主内存刷新。因此可以说volatile保证了多线程的可见性，而普通变量不能保证。

**有序性**：线程内有序 ；线程外无序。线程内观察。线程内观察，所有操作有序；线程观察另一个线程，所有操作无序。
线程内表现为串行语义；线程间指指令重排、工作内存和主内存同步延迟。

volatile、synchronized保证线程之间有序性。
volatile关键字包含了禁止指令重排序。
synchronized则是由“一个变量在同一时刻只允许一个线程对其进行lock操作”，这个规则决定了同一个锁的两个同步块只能串行进入。

这三个特性synchronized关键字都可以实现。

#### 6、先行发生原则
java内存模型的“天然的”先行发生原则，无线任何同步器协助，可以在编码中直接使用，无需任何同步手段保障。
如果两个操作的关系不再此列，顺序性就没有保障，虚拟机可以对他们进行任意重排序。

**程序次序规则**：在一个线程内，安装程序代码顺序，书写的前面的操作先行发生于后面的操作。
准确的说，控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

**管程锁规定**：一个unlock操作先行发生于后面对同一个锁的lock操作。强调“同一个锁”，“后面”是指时间先后顺序。synchronized关键字实现

**volatile**:对一个volatile变量的写操作先行发生于后面对这个变量的读操作，“后面”是指时间先后顺序。

**线程启动规则**：Thread对象的start()方法先行与发生于次线程的每一个动作。

**线程终止规则**:线程中所有操作都先行发生于对此线程的终止检测，通过Thread.join()方法结束、Thread.isAlive()返回值等手段检测
线程已经终止执行。也就是说正在执行的代码优先于终止检测

**线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法
检测到是否有中断发生。

**对象终结规则**：对象初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。

**传递性**：如果操作A先行发生于操作B,操作B先行发生于操作C，那么操作A先行发生于操作C。

### 三、Java与线程
#### 1、线程的实现
**使用内核线程实现**
内核线程之间由操作系统内核支持的线程，这种线程由内核完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射
到各个处理器上。

程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口--轻量级进程，每个轻量级进程都由一个内核线程支持，因此只有
先支持内核线程，才能有轻量级进程，这种轻量级进程与内核线程之间1:1关系称为一对一线程模型。

轻量级进程局限性：由于基于内核线程实现，各种线程操作都吸引进行系统调用，调用系统的代价较高，需要在用户态和内核态中来回切换，
每个轻量级进程都需要内核线程支持，消耗内核资源。

**使用用户线程实现**
广义来讲一个线程只要不是内核线程，就可以认为是用户线程。狭义上用户的线程是指完全建立在用户控件的线程库上，系统内核不会感知
线程存在的实现。用户线程的建立同步销毁和调度都是在用户态完成，不需要内核的帮助。
由于不需要切换到内核态，操作非常快且消耗低，能够支持规模更大的线程数量，可以支持1：N的线程模型。
缺点：所有的线程操作都需要用户自己处理，导致用户程序实现比较复杂。

**使用用户线程加轻量级进程混合实现**
用户线程建立在用户控件，用户线程创建、切换、析构等操作依然廉价，并可以支持大规模用户线程并发；
轻量级进程作为用户线程和内核线程之间的桥梁，使内核提供的线程调度功能和处理器映射，降低了进程被完全阻塞的风险。
用户线程与轻量级进程的数据量是不确定的，即N:M的关系，多对多线程模型。

**Java的线程实现**
基于操作系统原生线程模型来实现。Windows、Linux系统版都是一对一线程模型实现的，一个java线程就映射一个轻量级进程中，
Solaris平台由于操作系统可以同时指出一对一及多对多，因此solaris版的jdk中也提供了对应的参数进行支持。

#### 2、Java线程调度
线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种协同式线程调度，抢占式线程调度。

协同式调度：线程的执行时间由线程本身控制，线程把自己的工作实行完成之后，主动通知系统切换到另一个线程上。
优点：实现简单
缺点：线程执行时间不可控，可能存在线程一直阻塞。
抢占式调度：线程将由系统来分配执行时间，线程切换不由本身决定。也是当前java使用的线程调度方式。

#### 3、状态转换
java语言定义了5中线程状态
* 新建(New):创建后尚未启动的线程
* 运行(Runable)：包括了操作系统线程状态中Running和Ready，也就是处于此状态的线程可能正在执行也有可能等待CPU分配执行时间。
* 无限期等待(Waiting):不会被分配cpu执行时间，需要等待被其他线程显式唤醒。以下方法会产生：没有设置Timeout参数的Object.wait()方法；
    没有设置Timeout参数的Thread.join()方法；LockSupport.park()方法；

* 限期等待(Timed Waiting):不会被分配cpu执行时间，不管无需等待被其他线程显式唤醒，在一定时间后由系统自动唤醒。
    Thread.sleep()方法；设置了Timeout时间参数的Object.wait()、Thread.join()方法；LockSupport.parkNanos()方法；
    LockSupport.parkUntil()方法。
* 阻塞(Blocked):线程被阻塞，在程序等待进入同步区域时，线程进入这种状态。阻塞状态与等待状态区别：
    阻塞状态在等待着获取到一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；
    等待状态则是等待一段时间或者唤醒动作发生。
* 结束(Terminated):已终止线程的线程状态，线程已经结束执行。


